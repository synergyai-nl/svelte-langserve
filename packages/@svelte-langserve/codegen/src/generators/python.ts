import type { JSONSchema } from '../schema.js';

/**
 * Generate Python Pydantic models from JSON schema
 * This is a basic implementation - could be enhanced with datamodel-codegen
 */
export async function generatePydanticFromSchema(schema: JSONSchema): Promise<string> {
  let output = `"""Generated Pydantic models for svelte-langserve.
Do not edit this file directly.
"""

from typing import Dict, List, Optional, Union, Any
from datetime import datetime
from pydantic import BaseModel

`;

  // Basic implementation for common types
  if (schema.definitions) {
    for (const [name, definition] of Object.entries(schema.definitions)) {
      output += generatePydanticModel(name, definition as JSONSchema);
      output += '\n\n';
    }
  } else if (schema.properties) {
    // Single schema
    const name = (typeof schema.title === 'string' ? schema.title : 'GeneratedModel');
    output += generatePydanticModel(name, schema);
  }

  return output;
}

function generatePydanticModel(name: string, schema: JSONSchema): string {
  let model = `class ${name}(BaseModel):\n`;
  
  if (schema.properties) {
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const prop = propSchema as JSONSchema;
      const pythonType = jsonTypeToPython(prop);
      const required = Array.isArray(schema.required) ? schema.required.includes(propName) : false;
      const optional = required ? '' : ' = None';
      
      model += `    ${propName}: ${pythonType}${optional}\n`;
    }
  } else {
    model += '    pass\n';
  }
  
  return model;
}

function jsonTypeToPython(schema: JSONSchema): string {
  if (schema.type === 'string') {
    if (schema.format === 'date-time') return 'datetime';
    return 'str';
  }
  if (schema.type === 'number' || schema.type === 'integer') return 'int';
  if (schema.type === 'boolean') return 'bool';
  if (schema.type === 'array') {
    const itemType = schema.items ? jsonTypeToPython(schema.items as JSONSchema) : 'Any';
    return `List[${itemType}]`;
  }
  if (schema.type === 'object') {
    return 'Dict[str, Any]';
  }
  if (schema.anyOf || schema.oneOf) {
    return 'Union[str, Any]';  // Simplified
  }
  
  return 'Any';
}